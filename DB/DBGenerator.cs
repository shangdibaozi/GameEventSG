using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace GameHelperGenerator
{
    public static class DBGenerator
    {
        public static void Initialize(GeneratorInitializationContext context)
        {
            
        }

        public static void Execute(GeneratorExecutionContext context, GameHelperReceiver receiver)
        {
            // Group fields by their containing class
            var fieldsByClass = new Dictionary<INamedTypeSymbol, List<IFieldSymbol>>(SymbolEqualityComparer.Default);

            foreach (var field in receiver.Fields)
            {
                var model = context.Compilation.GetSemanticModel(field.SyntaxTree);

                // Get each variable declarator in the field (can have multiple like: int a, b;)
                foreach (var variable in field.Declaration.Variables)
                {
                    var fieldSymbol = model.GetDeclaredSymbol(variable) as IFieldSymbol;

                    if (fieldSymbol != null)
                    {
                        // Check if it has the DB attribute
                        var hasDBAttribute = fieldSymbol.GetAttributes().Any(attr =>
                            attr.AttributeClass?.Name == "DBAttribute");

                        if (hasDBAttribute)
                        {
                            var containingClass = fieldSymbol.ContainingType;
                            if (!fieldsByClass.ContainsKey(containingClass))
                            {
                                fieldsByClass[containingClass] = new List<IFieldSymbol>();
                            }
                            fieldsByClass[containingClass].Add(fieldSymbol);
                        }
                    }
                }
            }

            // Generate source code for each class
            foreach (var pair in fieldsByClass)
            {
                var classSymbol = pair.Key;
                var fields = pair.Value;

                var source = GenerateSourceCode(classSymbol, fields);
                var fileName = $"{classSymbol.Name}_DBProperties.g.cs";
                context.AddSource(fileName, SourceText.From(source, Encoding.UTF8));
            }
        }

        private static string GenerateSourceCode(INamedTypeSymbol classSymbol, List<IFieldSymbol> fields)
        {
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            
            // Add namespace if the class is in one
            var namespaceName = classSymbol.ContainingNamespace?.ToDisplayString();
            var hasNamespace = !string.IsNullOrEmpty(namespaceName) && namespaceName != "<global namespace>";

            if (hasNamespace)
            {
                sb.AppendLine($"namespace {namespaceName}");
                sb.AppendLine("{");
            }

            // Generate partial class
            var indent = hasNamespace ? "    " : "";
            sb.AppendLine($"{indent}public partial class {classSymbol.Name}");
            sb.AppendLine($"{indent}{{");

            // Generate properties for each field
            foreach (var field in fields)
            {
                var propertyName = GetPropertyName(field.Name);
                var valueType = GetValueType(field.Type);
                if (valueType == null)
                {
                    continue;
                }

                sb.AppendLine($"{indent}    public {valueType} {propertyName}");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        get {{ return {field.Name}.Value; }}");
                sb.AppendLine($"{indent}        set {{ {field.Name}.Value = value; }}");
                sb.AppendLine($"{indent}    }}");
                sb.AppendLine();
            }

            sb.AppendLine($"{indent}}}");

            if (hasNamespace)
            {
                sb.AppendLine("}");
            }

            return sb.ToString();
        }

        private static string GetPropertyName(string fieldName)
        {
            // Remove leading underscore if present
            if (fieldName.StartsWith("_"))
            {
                fieldName = fieldName.Substring(1);
            }
            
            // Return the field name (already camelCase from the example)
            return fieldName;
        }

        private static string GetValueType(ITypeSymbol fieldType)
        {
            // Try to find the Value property to determine the type
            var valueProp = fieldType.GetMembers("Value").FirstOrDefault() as IPropertySymbol;
            
            if (valueProp != null)
            {
                return valueProp.Type.ToDisplayString();
            }

            // Default fallback - try to extract from generic type
            if (fieldType is INamedTypeSymbol namedType)
            {
                var typeName = namedType.Name;
                
                // Handle common DB types
                if (typeName.StartsWith("DB") && typeName.Length > 2)
                {
                    var baseType = typeName.Substring(2); // Remove "DB" prefix
                    
                    // Map common types
                    switch (baseType)
                    {
                        case "Int":
                            return "int";
                        case "Long":
                            return "long";
                        case "Float":
                            return "float";
                        case "Double":
                            return "double";
                        case "String":
                            return "string";
                        case "Bool":
                            return "bool";
                        default:
                            return null;
                    }
                }
            }

            return null;
        }
    }
}