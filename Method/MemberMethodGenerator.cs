using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace GameHelperGenerator
{
    public static class MemberMethodGenerator
    {
        public static void Execute(GeneratorExecutionContext context, GameHelperReceiver receiver)
        {
            // 遍历所有收集到的类
            foreach (var classDeclaration in receiver.Classes)
            {
                var model = context.Compilation.GetSemanticModel(classDeclaration.SyntaxTree);
                if (!(model.GetDeclaredSymbol(classDeclaration) is INamedTypeSymbol classSymbol))
                    continue;

                // 获取类上所有的MethodCollectorAttribute
                var collectorAttributes = classSymbol.GetAttributes()
                    .Where(attr => attr.AttributeClass?.Name == "MethodCollectorAttribute")
                    .ToList();
                
                if (collectorAttributes.Count == 0)
                    continue;

                // 按SuffixName分组收集方法
                var methodsBySuffix = new Dictionary<string, List<IMethodSymbol>>();

                // 遍历每个MethodCollectorAttribute
                foreach (var collectorAttr in collectorAttributes)
                {
                    if (collectorAttr.ConstructorArguments.Length == 0)
                        continue;

                    var suffixName = collectorAttr.ConstructorArguments[0].Value?.ToString();
                    if (string.IsNullOrEmpty(suffixName))
                        continue;

                    // 收集所有方法名以suffixName开头的方法
                    var matchingMethods = new List<IMethodSymbol>();
                    foreach (var member in classSymbol.GetMembers())
                    {
                        if (member is IMethodSymbol methodSymbol && 
                            methodSymbol.MethodKind == MethodKind.Ordinary &&
                            methodSymbol.Name.StartsWith(suffixName))
                        {
                            matchingMethods.Add(methodSymbol);
                        }
                    }

                    if (matchingMethods.Count > 0)
                    {
                        methodsBySuffix[suffixName] = matchingMethods;
                    }
                }

                // 如果找到了匹配的方法，生成分部类
                if (methodsBySuffix.Count > 0)
                {
                    var source = GeneratePartialClass(classSymbol, methodsBySuffix);
                    var fileName = $"{classSymbol.Name}_MethodCollector.g.cs";
                    context.AddSource(fileName, SourceText.From(source, Encoding.UTF8));
                }
            }
        }

        private static string GeneratePartialClass(INamedTypeSymbol classSymbol, 
            Dictionary<string, List<IMethodSymbol>> methodsBySuffix)
        {
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine();

            // 添加命名空间
            if (!classSymbol.ContainingNamespace.IsGlobalNamespace)
            {
                sb.AppendLine($"namespace {classSymbol.ContainingNamespace.ToDisplayString()}");
                sb.AppendLine("{");
            }

            // 生成分部类
            var classModifiers = GetClassModifiers(classSymbol);
            sb.AppendLine($"    {classModifiers} partial class {classSymbol.Name}");
            sb.AppendLine("    {");

            // 为每个SuffixName生成一个方法
            foreach (var kvp in methodsBySuffix)
            {
                var suffixName = kvp.Key;
                var methods = kvp.Value;

                if (methods.Count == 0)
                    continue;

                var firstMethod = methods[0];

                // 使用第一个方法的参数作为生成方法的参数
                var parameters = GetMethodParameters(firstMethod);
                var argumentList = GetArgumentList(firstMethod.Parameters);
                var returnType = firstMethod.ReturnType.ToDisplayString();
                
                // 如果收集的方法是static，生成的方法也应该是static
                var staticModifier = firstMethod.IsStatic ? "static " : "";

                sb.AppendLine($"        public {staticModifier}{returnType} {suffixName}({parameters})");
                sb.AppendLine("        {");

                // 调用所有匹配的方法
                for (int i = 0; i < methods.Count; i++)
                {
                    var method = methods[i];
                    var isVoid = method.ReturnsVoid;
                    var isLast = i == methods.Count - 1;

                    // 如果是静态方法，需要加上类名前缀
                    var methodCall = method.IsStatic 
                        ? $"{classSymbol.Name}.{method.Name}({argumentList})" 
                        : $"{method.Name}({argumentList})";
                    
                    if (isVoid)
                    {
                        sb.AppendLine($"            {methodCall};");
                    }
                    else
                    {
                        if (isLast)
                        {
                            sb.AppendLine($"            return {methodCall};");
                        }
                        else
                        {
                            sb.AppendLine($"            {methodCall};");
                        }
                    }
                }

                // 如果方法有返回值但没有方法调用
                if (!firstMethod.ReturnsVoid && methods.Count == 0)
                {
                    sb.AppendLine($"            return default({returnType});");
                }

                sb.AppendLine("        }");
                sb.AppendLine();
            }

            sb.AppendLine("    }");

            // 关闭命名空间
            if (!classSymbol.ContainingNamespace.IsGlobalNamespace)
            {
                sb.AppendLine("}");
            }

            return sb.ToString();
        }

        private static string GetClassModifiers(INamedTypeSymbol classSymbol)
        {
            var modifiers = new List<string>();

            if (classSymbol.DeclaredAccessibility == Accessibility.Public)
                modifiers.Add("public");
            else if (classSymbol.DeclaredAccessibility == Accessibility.Internal)
                modifiers.Add("internal");
            else if (classSymbol.DeclaredAccessibility == Accessibility.Private)
                modifiers.Add("private");
            else if (classSymbol.DeclaredAccessibility == Accessibility.Protected)
                modifiers.Add("protected");

            if (classSymbol.IsAbstract && !classSymbol.IsStatic)
                modifiers.Add("abstract");
            else if (classSymbol.IsStatic)
                modifiers.Add("static");
            else if (classSymbol.IsSealed)
                modifiers.Add("sealed");

            return string.Join(" ", modifiers);
        }

        private static string GetMethodParameters(IMethodSymbol method)
        {
            var parameters = new List<string>();
            foreach (var parameter in method.Parameters)
            {
                var refModifier = "";
                if (parameter.RefKind == RefKind.Ref)
                    refModifier = "ref ";
                else if (parameter.RefKind == RefKind.Out)
                    refModifier = "out ";
                else if (parameter.RefKind == RefKind.In)
                    refModifier = "in ";

                parameters.Add($"{refModifier}{parameter.Type.ToDisplayString()} {parameter.Name}");
            }
            return string.Join(", ", parameters);
        }

        private static string GetArgumentList(IEnumerable<IParameterSymbol> parameters)
        {
            var arguments = new List<string>();
            foreach (var parameter in parameters)
            {
                var refModifier = "";
                if (parameter.RefKind == RefKind.Ref)
                    refModifier = "ref ";
                else if (parameter.RefKind == RefKind.Out)
                    refModifier = "out ";
                else if (parameter.RefKind == RefKind.In)
                    refModifier = "in ";

                arguments.Add($"{refModifier}{parameter.Name}");
            }
            return string.Join(", ", arguments);
        }
    }
}

